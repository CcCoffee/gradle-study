import groovy.xml.MarkupBuilder
apply plugin: 'com.android.application'

//def mApplicationId = "com.example.myapplication"

//定义扩展属性
ext {
    applicationId = "com.example.myapplication"
}

android {
    compileSdkVersion this.rootProject.android.compileSdkVersion
    buildToolsVersion "29.0.2"
    defaultConfig {
//        applicationId mApplicationId
        applicationId this.applicationId
        minSdkVersion 24
        targetSdkVersion mTargetSdkVersion
        versionCode 1
        versionName "1.0"
        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
}

// 为应用程序添加第三方依赖
dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])//本地jar包
    implementation 'androidx.appcompat:appcompat:1.1.0'//远程第三方依赖
    implementation 'androidx.constraintlayout:constraintlayout:1.1.3'
    implementation 'com.google.android.material:material:1.0.0'
    implementation project(path: ':mylibrary')//本地库工程
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'androidx.test.ext:junit:1.1.0'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.1.1'
}

//copy {
//    from file('proguard-rules.pro')
//    into this.getRootProject().getRootDir()
//}

copy {
    from file("${this.getBuildDir().path}/outputs/apk/")
    into "${this.getRootProject().getBuildDir().path}/apk/"
//    exclude('output.json')
//    rename {'test.apk'}
}

fileTree('build/outputs/apk/') { ConfigurableFileTree configurableFileTree ->
    configurableFileTree.visit { FileVisitDetails fileVisitDetails ->
        println "复制文件${fileVisitDetails.getFile().getName()}"
        copy {
            from fileVisitDetails.getFile()
            into this.getRootProject().getBuildDir().absolutePath + '/test/'
        }
    }
}

// task的两种定义方式
// 方式一： 直接让project通过task函数去创建并管理所有task
// 在创建task的时候同时指定最基本的配置，如group和description
// group会对同个项目下所有相同的group的task进行归并分组
// description会对每个task进行注释，就像html中title的作用
task helloTask(group: 'imooc', description: 'task study') {
    println 'I am hellotask'
    doFirst {
        println '3. The task group is :' + group
    }
    doFirst {
        //doFirst可以执行多次
        println '2. The task description is :' + description
    }
}

helloTask.doFirst {
    println '1. 可以通过task在外面调用doFirst'
}

// 方式二：通过TaskContainer去创建Task
this.tasks.create("myTask") {
    setGroup("imooc")
    setDescription("task study")
    println 'I am myTask, created by tasks API'
}

this.afterEvaluate { Project project ->
    //保证所有整个工程的task已经配置完毕
    //强烈建议在这个声明周期方法的闭包中去调用task，因为能够保证task被准备好，不会遇到task找不到异常
    def startBuildTime, endBuildTime
    def preBuildTask = project.tasks.getByName('preBuild')
    preBuildTask.doFirst {
        startBuildTime = System.currentTimeMillis()
        println "The start time is : $startBuildTime"
    }
    def buildTask = project.tasks.getByName("build")
    buildTask.doLast {
        endBuildTime = System.currentTimeMillis()
        println "The build time is ${(endBuildTime - startBuildTime)/1000} seconds"
    }
    def taskX = project.tasks.getByName("taskX")
    taskX.dependsOn(project.tasks.findAll { Task task ->
        return task.name.startsWith("lib")
    })
}

task lib1 {
    doLast {
        println 'lib1'
    }
}

task lib2 {
    doLast {
        println 'lib2'
    }
}

task nolib {
    doLast {
        println 'nolib'
    }
}

task taskX {
//    dependsOn this.tasks.findAll {Task task ->
//        return task.name.startsWith("lib")
//    }
    doLast {
        println 'taskX'
    }
}

task taskY {
    doLast {
        println 'taskY'
    }
}

this.taskY.dependsOn(taskX)

task taskZ ('dependsOn': [taskX, taskY]){
    doLast {
        println 'taskZ'
    }
}


task handleReleaseFile {
    def destDir = new File(this.buildDir.absolutePath, "/generated/releases")
    doLast{
        println '开始解析releases.xml文件...'
        destDir.mkdir()
        def file = file("releases.xml")
        new XmlParser().parse(file).children().each { Node release ->
            def versionCode = release.versionCode.text()
            def versionName = release.versionName.text()
            def versionInfo = release.versionInfo.text()
            File releaseFile = new File(destDir,versionCode)
            releaseFile.withWriter {writer ->
                writer.writeLine("$versionCode -> $versionName -> $versionInfo")
            }
        }
    }
}

task handleReleaseFileTest ('dependsOn':handleReleaseFile){
    def targetDir = new File(this.buildDir.absolutePath, "/generated/releases")
    doLast {
        fileTree(targetDir).each {File file ->
            println file.name
        }
    }
}

ext {
    versionName = "1.5.0"
    versionCode = "150"
    versionInfo = "测试"
    destFile = file('releases.xml')
    if(destFile!= null && !destFile.exists()){
        destFile.createNewFile()
    }
}


task writeTask {
    inputs.property('versionCode', this.versionCode)
    inputs.property('versionName', this.versionName)
    inputs.property('versionInfo', this.versionInfo)
    outputs.file this.destFile
    doLast {
        //将输入的内容写入到输出文件中去
        def data = inputs.getProperties()
        File file = outputs.getFiles().getSingleFile()
        def versionMsg = new VersionMsg(data)
        //将实体对象写入到xml文件中
        def sw = new StringWriter()
        def xmlBuilder = new MarkupBuilder(sw)
        if (file.text != null && file.text.size() <= 0) {
            //没有内容
            xmlBuilder.releases {
                release {
                    versionCode(versionMsg.versionCode)
                    versionName(versionMsg.versionName)
                    versionInfo(versionMsg.versionInfo)
                }
            }
            //直接写入
            file.withWriter { writer -> writer.append(sw.toString())
            }
        } else {
            //已有其它版本内容
            xmlBuilder.release {
                versionCode(versionMsg.versionCode)
                versionName(versionMsg.versionName)
                versionInfo(versionMsg.versionInfo)
            }
            //插入到最后一行前面
            def lines = file.readLines()
            def lengths = lines.size() - 1
            file.withWriter { writer ->
                lines.eachWithIndex { line, index ->
                    if (index != lengths) {
                        writer.append(line + '\r\n')
                    } else if (index == lengths) {
                        writer.append('\r\r\n' + sw.toString() + '\r\n')
                        writer.append(lines.get(lengths))
                    }
                }
            }
        }
    }
}

class VersionMsg {
    String versionCode
    String versionName
    String versionInfo
}

task readTask {
    //指定输入文件为上一个task的输出
    inputs.file this.destFile
    doLast {
        //读取输入文件的内容并显示
        def file = inputs.files.singleFile
        println file.text
    }
}


task taskTest {
    dependsOn writeTask, readTask
    doLast {
        println '输入输出任务结束'
    }
}

//不为task指定依赖关系也可以实现执行顺序的指定
task task1{
    doLast {
        println "task1"
    }
}

task task2{
    mustRunAfter "task1"
    doLast {
        println "task2"
    }
}

task task3{
    mustRunAfter = ["task1", "task2"]
    doLast {
        println "task3"
    }
}