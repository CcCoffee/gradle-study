apply plugin: 'com.android.application'

//def mApplicationId = "com.example.myapplication"

//定义扩展属性
ext {
    applicationId = "com.example.myapplication"
}

android {
    compileSdkVersion this.rootProject.android.compileSdkVersion
    buildToolsVersion "29.0.2"
    defaultConfig {
//        applicationId mApplicationId
        applicationId this.applicationId
        minSdkVersion 24
        targetSdkVersion mTargetSdkVersion
        versionCode 1
        versionName "1.0"
        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
}

// 为应用程序添加第三方依赖
dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])//本地jar包
    implementation 'androidx.appcompat:appcompat:1.1.0'//远程第三方依赖
    implementation 'androidx.constraintlayout:constraintlayout:1.1.3'
    implementation 'com.google.android.material:material:1.0.0'
    implementation project(path: ':mylibrary')//本地库工程
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'androidx.test.ext:junit:1.1.0'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.1.1'
}

//copy {
//    from file('proguard-rules.pro')
//    into this.getRootProject().getRootDir()
//}

copy {
    from file("${this.getBuildDir().path}/outputs/apk/")
    into "${this.getRootProject().getBuildDir().path}/apk/"
//    exclude('output.json')
//    rename {'test.apk'}
}

fileTree('build/outputs/apk/') { ConfigurableFileTree configurableFileTree ->
    configurableFileTree.visit { FileVisitDetails fileVisitDetails ->
        println "复制文件${fileVisitDetails.getFile().getName()}"
        copy {
            from fileVisitDetails.getFile()
            into this.getRootProject().getBuildDir().absolutePath + '/test/'
        }
    }
}

// task的两种定义方式
// 方式一： 直接让project通过task函数去创建并管理所有task
// 在创建task的时候同时指定最基本的配置，如group和description
// group会对同个项目下所有相同的group的task进行归并分组
// description会对每个task进行注释，就像html中title的作用
task helloTask(group: 'imooc', description: 'task study') {
    println 'I am hellotask'
    doFirst {
        println '3. The task group is :' + group
    }
    doFirst {
        //doFirst可以执行多次
        println '2. The task description is :' + description
    }
}

helloTask.doFirst {
    println '1. 可以通过task在外面调用doFirst'
}

// 方式二：通过TaskContainer去创建Task
this.tasks.create("myTask") {
    setGroup("imooc")
    setDescription("task study")
    println 'I am myTask, created by tasks API'
}

this.afterEvaluate { Project project ->
    //保证所有整个工程的task已经配置完毕
    //强烈建议在这个声明周期方法的闭包中去调用task，因为能够保证task被准备好，不会遇到task找不到异常
    def startBuildTime, endBuildTime
    def preBuildTask = project.tasks.getByName('preBuild')
    preBuildTask.doFirst {
        startBuildTime = System.currentTimeMillis()
        println "The start time is : $startBuildTime"
    }
    def buildTask = project.tasks.getByName("build")
    buildTask.doLast {
        endBuildTime = System.currentTimeMillis()
        println "The build time is ${(endBuildTime - startBuildTime)/1000} seconds"
    }
    def taskX = project.tasks.getByName("taskX")
    taskX.dependsOn(project.tasks.findAll { Task task ->
        return task.name.startsWith("lib")
    })
}

task lib1 {
    doLast {
        println 'lib1'
    }
}

task lib2 {
    doLast {
        println 'lib2'
    }
}

task nolib {
    doLast {
        println 'nolib'
    }
}

task taskX {
//    dependsOn this.tasks.findAll {Task task ->
//        return task.name.startsWith("lib")
//    }
    doLast {
        println 'taskX'
    }
}

task taskY {
    doLast {
        println 'taskY'
    }
}

this.taskY.dependsOn(taskX)

task taskZ ('dependsOn': [taskX, taskY]){
    doLast {
        println 'taskZ'
    }
}


task handleReleaseFile {
    def destDir = new File(this.buildDir.absolutePath, "/generated/releases")
    doLast{
        println '开始解析releases.xml文件...'
        destDir.mkdir()
        def file = file("releases.xml")
        new XmlParser().parse(file).children().each { Node release ->
            def versionCode = release.versionCode.text()
            def versionName = release.versionName.text()
            def versionInfo = release.versionInfo.text()
            File releaseFile = new File(destDir,versionCode)
            releaseFile.withWriter {writer ->
                writer.writeLine("$versionCode -> $versionName -> $versionInfo")
            }
        }
    }
}

task handleReleaseFileTest ('dependsOn':handleReleaseFile){
    def targetDir = new File(this.buildDir.absolutePath, "/generated/releases")
    doLast {
        fileTree(targetDir).each {File file ->
            println file.name
        }
    }
}

